
Color Sensor Demo Code.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000003a  00800200  00000722  000007b6  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000722  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000016  0080023a  0080023a  000007f0  2**0
                  ALLOC
  3 .stab         000006e4  00000000  00000000  000007f0  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00000085  00000000  00000000  00000ed4  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 000000a0  00000000  00000000  00000f60  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00000d55  00000000  00000000  00001000  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000231  00000000  00000000  00001d55  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000005bb  00000000  00000000  00001f86  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000214  00000000  00000000  00002544  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    0000030e  00000000  00000000  00002758  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00000343  00000000  00000000  00002a66  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 72 00 	jmp	0xe4	; 0xe4 <__ctors_end>
   4:	0c 94 3e 02 	jmp	0x47c	; 0x47c <__vector_1>
   8:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
   c:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  10:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  14:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  18:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  1c:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  20:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  24:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  28:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  2c:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  30:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  34:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  38:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  3c:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  40:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  44:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  48:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  4c:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  50:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  54:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  58:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  5c:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  60:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  64:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  68:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  6c:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  70:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  74:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  78:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  7c:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  80:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  84:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  88:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  8c:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  90:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  94:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  98:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  9c:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  a0:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  a4:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  a8:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  ac:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  b0:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  b4:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  b8:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  bc:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  c0:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  c4:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  c8:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  cc:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  d0:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  d4:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  d8:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  dc:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  e0:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>

000000e4 <__ctors_end>:
  e4:	11 24       	eor	r1, r1
  e6:	1f be       	out	0x3f, r1	; 63
  e8:	cf ef       	ldi	r28, 0xFF	; 255
  ea:	d1 e2       	ldi	r29, 0x21	; 33
  ec:	de bf       	out	0x3e, r29	; 62
  ee:	cd bf       	out	0x3d, r28	; 61
  f0:	00 e0       	ldi	r16, 0x00	; 0
  f2:	0c bf       	out	0x3c, r16	; 60

000000f4 <__do_copy_data>:
  f4:	12 e0       	ldi	r17, 0x02	; 2
  f6:	a0 e0       	ldi	r26, 0x00	; 0
  f8:	b2 e0       	ldi	r27, 0x02	; 2
  fa:	e2 e2       	ldi	r30, 0x22	; 34
  fc:	f7 e0       	ldi	r31, 0x07	; 7
  fe:	00 e0       	ldi	r16, 0x00	; 0
 100:	0b bf       	out	0x3b, r16	; 59
 102:	02 c0       	rjmp	.+4      	; 0x108 <__do_copy_data+0x14>
 104:	07 90       	elpm	r0, Z+
 106:	0d 92       	st	X+, r0
 108:	aa 33       	cpi	r26, 0x3A	; 58
 10a:	b1 07       	cpc	r27, r17
 10c:	d9 f7       	brne	.-10     	; 0x104 <__do_copy_data+0x10>

0000010e <__do_clear_bss>:
 10e:	12 e0       	ldi	r17, 0x02	; 2
 110:	aa e3       	ldi	r26, 0x3A	; 58
 112:	b2 e0       	ldi	r27, 0x02	; 2
 114:	01 c0       	rjmp	.+2      	; 0x118 <.do_clear_bss_start>

00000116 <.do_clear_bss_loop>:
 116:	1d 92       	st	X+, r1

00000118 <.do_clear_bss_start>:
 118:	a0 35       	cpi	r26, 0x50	; 80
 11a:	b1 07       	cpc	r27, r17
 11c:	e1 f7       	brne	.-8      	; 0x116 <.do_clear_bss_loop>
 11e:	0e 94 9e 02 	call	0x53c	; 0x53c <main>
 122:	0c 94 8f 03 	jmp	0x71e	; 0x71e <_exit>

00000126 <__bad_interrupt>:
 126:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

0000012a <lcd_set_4bit>:
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 12a:	86 e6       	ldi	r24, 0x66	; 102
 12c:	9e e0       	ldi	r25, 0x0E	; 14
 12e:	01 97       	sbiw	r24, 0x01	; 1
 130:	f1 f7       	brne	.-4      	; 0x12e <lcd_set_4bit+0x4>
 132:	00 00       	nop
/*****Function to Reset LCD*****/
void lcd_set_4bit()
{
	_delay_ms(1);

	cbit(lcd_port,RS);				//RS=0 --- Command Input
 134:	40 98       	cbi	0x08, 0	; 8
	cbit(lcd_port,RW);				//RW=0 --- Writing to LCD
 136:	41 98       	cbi	0x08, 1	; 8
	lcd_port = 0x30;				//Sending 3
 138:	80 e3       	ldi	r24, 0x30	; 48
 13a:	88 b9       	out	0x08, r24	; 8
	sbit(lcd_port,EN);				//Set Enable Pin
 13c:	42 9a       	sbi	0x08, 2	; 8
 13e:	ef ef       	ldi	r30, 0xFF	; 255
 140:	f7 e4       	ldi	r31, 0x47	; 71
 142:	31 97       	sbiw	r30, 0x01	; 1
 144:	f1 f7       	brne	.-4      	; 0x142 <lcd_set_4bit+0x18>
 146:	00 c0       	rjmp	.+0      	; 0x148 <lcd_set_4bit+0x1e>
 148:	00 00       	nop
	_delay_ms(5);					//Delay
	cbit(lcd_port,EN);				//Clear Enable Pin
 14a:	42 98       	cbi	0x08, 2	; 8
 14c:	e6 e6       	ldi	r30, 0x66	; 102
 14e:	fe e0       	ldi	r31, 0x0E	; 14
 150:	31 97       	sbiw	r30, 0x01	; 1
 152:	f1 f7       	brne	.-4      	; 0x150 <lcd_set_4bit+0x26>
 154:	00 00       	nop

	_delay_ms(1);

	cbit(lcd_port,RS);				//RS=0 --- Command Input
 156:	40 98       	cbi	0x08, 0	; 8
	cbit(lcd_port,RW);				//RW=0 --- Writing to LCD
 158:	41 98       	cbi	0x08, 1	; 8
	lcd_port = 0x30;				//Sending 3
 15a:	88 b9       	out	0x08, r24	; 8
	sbit(lcd_port,EN);				//Set Enable Pin
 15c:	42 9a       	sbi	0x08, 2	; 8
 15e:	ef ef       	ldi	r30, 0xFF	; 255
 160:	f7 e4       	ldi	r31, 0x47	; 71
 162:	31 97       	sbiw	r30, 0x01	; 1
 164:	f1 f7       	brne	.-4      	; 0x162 <lcd_set_4bit+0x38>
 166:	00 c0       	rjmp	.+0      	; 0x168 <lcd_set_4bit+0x3e>
 168:	00 00       	nop
	_delay_ms(5);					//Delay
	cbit(lcd_port,EN);				//Clear Enable Pin
 16a:	42 98       	cbi	0x08, 2	; 8
 16c:	e6 e6       	ldi	r30, 0x66	; 102
 16e:	fe e0       	ldi	r31, 0x0E	; 14
 170:	31 97       	sbiw	r30, 0x01	; 1
 172:	f1 f7       	brne	.-4      	; 0x170 <lcd_set_4bit+0x46>
 174:	00 00       	nop

	_delay_ms(1);

	cbit(lcd_port,RS);				//RS=0 --- Command Input
 176:	40 98       	cbi	0x08, 0	; 8
	cbit(lcd_port,RW);				//RW=0 --- Writing to LCD
 178:	41 98       	cbi	0x08, 1	; 8
	lcd_port = 0x30;				//Sending 3
 17a:	88 b9       	out	0x08, r24	; 8
	sbit(lcd_port,EN);				//Set Enable Pin
 17c:	42 9a       	sbi	0x08, 2	; 8
 17e:	8f ef       	ldi	r24, 0xFF	; 255
 180:	97 e4       	ldi	r25, 0x47	; 71
 182:	01 97       	sbiw	r24, 0x01	; 1
 184:	f1 f7       	brne	.-4      	; 0x182 <lcd_set_4bit+0x58>
 186:	00 c0       	rjmp	.+0      	; 0x188 <lcd_set_4bit+0x5e>
 188:	00 00       	nop
	_delay_ms(5);					//Delay
	cbit(lcd_port,EN);				//Clear Enable Pin
 18a:	42 98       	cbi	0x08, 2	; 8
 18c:	e6 e6       	ldi	r30, 0x66	; 102
 18e:	fe e0       	ldi	r31, 0x0E	; 14
 190:	31 97       	sbiw	r30, 0x01	; 1
 192:	f1 f7       	brne	.-4      	; 0x190 <lcd_set_4bit+0x66>
 194:	00 00       	nop

	_delay_ms(1);

	cbit(lcd_port,RS);				//RS=0 --- Command Input
 196:	40 98       	cbi	0x08, 0	; 8
	cbit(lcd_port,RW);				//RW=0 --- Writing to LCD
 198:	41 98       	cbi	0x08, 1	; 8
	lcd_port = 0x20;				//Sending 2 to initialise LCD 4-bit mode
 19a:	80 e2       	ldi	r24, 0x20	; 32
 19c:	88 b9       	out	0x08, r24	; 8
	sbit(lcd_port,EN);				//Set Enable Pin
 19e:	42 9a       	sbi	0x08, 2	; 8
 1a0:	8f ef       	ldi	r24, 0xFF	; 255
 1a2:	97 e4       	ldi	r25, 0x47	; 71
 1a4:	01 97       	sbiw	r24, 0x01	; 1
 1a6:	f1 f7       	brne	.-4      	; 0x1a4 <lcd_set_4bit+0x7a>
 1a8:	00 c0       	rjmp	.+0      	; 0x1aa <lcd_set_4bit+0x80>
 1aa:	00 00       	nop
	_delay_ms(5);					//Delay
	cbit(lcd_port,EN);				//Clear Enable Pin
 1ac:	42 98       	cbi	0x08, 2	; 8


}
 1ae:	08 95       	ret

000001b0 <lcd_wr_command>:
void lcd_wr_command(unsigned char cmd)
{
	unsigned char temp;
	temp = cmd;
	temp = temp & 0xF0;
	lcd_port &= 0x0F;
 1b0:	98 b1       	in	r25, 0x08	; 8
 1b2:	9f 70       	andi	r25, 0x0F	; 15
 1b4:	98 b9       	out	0x08, r25	; 8
	lcd_port |= temp;
 1b6:	98 b1       	in	r25, 0x08	; 8
/*****Function to Write Command on LCD*****/
void lcd_wr_command(unsigned char cmd)
{
	unsigned char temp;
	temp = cmd;
	temp = temp & 0xF0;
 1b8:	28 2f       	mov	r18, r24
 1ba:	20 7f       	andi	r18, 0xF0	; 240
	lcd_port &= 0x0F;
	lcd_port |= temp;
 1bc:	92 2b       	or	r25, r18
 1be:	98 b9       	out	0x08, r25	; 8
	cbit(lcd_port,RS);
 1c0:	40 98       	cbi	0x08, 0	; 8
	cbit(lcd_port,RW);
 1c2:	41 98       	cbi	0x08, 1	; 8
	sbit(lcd_port,EN);
 1c4:	42 9a       	sbi	0x08, 2	; 8
 1c6:	ef ef       	ldi	r30, 0xFF	; 255
 1c8:	f7 e4       	ldi	r31, 0x47	; 71
 1ca:	31 97       	sbiw	r30, 0x01	; 1
 1cc:	f1 f7       	brne	.-4      	; 0x1ca <lcd_wr_command+0x1a>
 1ce:	00 c0       	rjmp	.+0      	; 0x1d0 <lcd_wr_command+0x20>
 1d0:	00 00       	nop
	_delay_ms(5);
	cbit(lcd_port,EN);
 1d2:	42 98       	cbi	0x08, 2	; 8

	cmd = cmd & 0x0F;
	cmd = cmd<<4;
	lcd_port &= 0x0F;
 1d4:	98 b1       	in	r25, 0x08	; 8
 1d6:	9f 70       	andi	r25, 0x0F	; 15
 1d8:	98 b9       	out	0x08, r25	; 8
	lcd_port |= cmd;
 1da:	98 b1       	in	r25, 0x08	; 8
	sbit(lcd_port,EN);
	_delay_ms(5);
	cbit(lcd_port,EN);

	cmd = cmd & 0x0F;
	cmd = cmd<<4;
 1dc:	82 95       	swap	r24
 1de:	80 7f       	andi	r24, 0xF0	; 240
	lcd_port &= 0x0F;
	lcd_port |= cmd;
 1e0:	89 2b       	or	r24, r25
 1e2:	88 b9       	out	0x08, r24	; 8
	cbit(lcd_port,RS);
 1e4:	40 98       	cbi	0x08, 0	; 8
	cbit(lcd_port,RW);
 1e6:	41 98       	cbi	0x08, 1	; 8
	sbit(lcd_port,EN);
 1e8:	42 9a       	sbi	0x08, 2	; 8
 1ea:	8f ef       	ldi	r24, 0xFF	; 255
 1ec:	97 e4       	ldi	r25, 0x47	; 71
 1ee:	01 97       	sbiw	r24, 0x01	; 1
 1f0:	f1 f7       	brne	.-4      	; 0x1ee <lcd_wr_command+0x3e>
 1f2:	00 c0       	rjmp	.+0      	; 0x1f4 <lcd_wr_command+0x44>
 1f4:	00 00       	nop
	_delay_ms(5);
	cbit(lcd_port,EN);
 1f6:	42 98       	cbi	0x08, 2	; 8
}
 1f8:	08 95       	ret

000001fa <lcd_init>:
 1fa:	86 e6       	ldi	r24, 0x66	; 102
 1fc:	9e e0       	ldi	r25, 0x0E	; 14
 1fe:	01 97       	sbiw	r24, 0x01	; 1
 200:	f1 f7       	brne	.-4      	; 0x1fe <lcd_init+0x4>
 202:	00 00       	nop
/*****Function to Initialize LCD*****/
void lcd_init()
{
	_delay_ms(1);

	lcd_wr_command(0x28);			//LCD 4-bit mode and 2 lines.
 204:	88 e2       	ldi	r24, 0x28	; 40
 206:	0e 94 d8 00 	call	0x1b0	; 0x1b0 <lcd_wr_command>
	lcd_wr_command(0x01);
 20a:	81 e0       	ldi	r24, 0x01	; 1
 20c:	0e 94 d8 00 	call	0x1b0	; 0x1b0 <lcd_wr_command>
	lcd_wr_command(0x06);
 210:	86 e0       	ldi	r24, 0x06	; 6
 212:	0e 94 d8 00 	call	0x1b0	; 0x1b0 <lcd_wr_command>
	lcd_wr_command(0x0E);
 216:	8e e0       	ldi	r24, 0x0E	; 14
 218:	0e 94 d8 00 	call	0x1b0	; 0x1b0 <lcd_wr_command>
	lcd_wr_command(0x80);
 21c:	80 e8       	ldi	r24, 0x80	; 128
 21e:	0e 94 d8 00 	call	0x1b0	; 0x1b0 <lcd_wr_command>

}
 222:	08 95       	ret

00000224 <lcd_wr_char>:
void lcd_wr_char(char letter)
{
	char temp;
	temp = letter;
	temp = (temp & 0xF0);
	lcd_port &= 0x0F;
 224:	98 b1       	in	r25, 0x08	; 8
 226:	9f 70       	andi	r25, 0x0F	; 15
 228:	98 b9       	out	0x08, r25	; 8
	lcd_port |= temp;
 22a:	98 b1       	in	r25, 0x08	; 8
/*****Function to Write Data on LCD*****/
void lcd_wr_char(char letter)
{
	char temp;
	temp = letter;
	temp = (temp & 0xF0);
 22c:	28 2f       	mov	r18, r24
 22e:	20 7f       	andi	r18, 0xF0	; 240
	lcd_port &= 0x0F;
	lcd_port |= temp;
 230:	92 2b       	or	r25, r18
 232:	98 b9       	out	0x08, r25	; 8
	sbit(lcd_port,RS);
 234:	40 9a       	sbi	0x08, 0	; 8
	cbit(lcd_port,RW);
 236:	41 98       	cbi	0x08, 1	; 8
	sbit(lcd_port,EN);
 238:	42 9a       	sbi	0x08, 2	; 8
 23a:	ef ef       	ldi	r30, 0xFF	; 255
 23c:	f7 e4       	ldi	r31, 0x47	; 71
 23e:	31 97       	sbiw	r30, 0x01	; 1
 240:	f1 f7       	brne	.-4      	; 0x23e <lcd_wr_char+0x1a>
 242:	00 c0       	rjmp	.+0      	; 0x244 <lcd_wr_char+0x20>
 244:	00 00       	nop
	_delay_ms(5);
	cbit(lcd_port,EN);
 246:	42 98       	cbi	0x08, 2	; 8

	letter = letter & 0x0F;
	letter = letter<<4;
	lcd_port &= 0x0F;
 248:	98 b1       	in	r25, 0x08	; 8
 24a:	9f 70       	andi	r25, 0x0F	; 15
 24c:	98 b9       	out	0x08, r25	; 8
	lcd_port |= letter;
 24e:	98 b1       	in	r25, 0x08	; 8
	sbit(lcd_port,EN);
	_delay_ms(5);
	cbit(lcd_port,EN);

	letter = letter & 0x0F;
	letter = letter<<4;
 250:	82 95       	swap	r24
 252:	80 7f       	andi	r24, 0xF0	; 240
	lcd_port &= 0x0F;
	lcd_port |= letter;
 254:	89 2b       	or	r24, r25
 256:	88 b9       	out	0x08, r24	; 8
	sbit(lcd_port,RS);
 258:	40 9a       	sbi	0x08, 0	; 8
	cbit(lcd_port,RW);
 25a:	41 98       	cbi	0x08, 1	; 8
	sbit(lcd_port,EN);
 25c:	42 9a       	sbi	0x08, 2	; 8
 25e:	8f ef       	ldi	r24, 0xFF	; 255
 260:	97 e4       	ldi	r25, 0x47	; 71
 262:	01 97       	sbiw	r24, 0x01	; 1
 264:	f1 f7       	brne	.-4      	; 0x262 <lcd_wr_char+0x3e>
 266:	00 c0       	rjmp	.+0      	; 0x268 <lcd_wr_char+0x44>
 268:	00 00       	nop
	_delay_ms(5);
	cbit(lcd_port,EN);
 26a:	42 98       	cbi	0x08, 2	; 8
}
 26c:	08 95       	ret

0000026e <lcd_home>:


void lcd_home()
{
	lcd_wr_command(0x80);
 26e:	80 e8       	ldi	r24, 0x80	; 128
 270:	0e 94 d8 00 	call	0x1b0	; 0x1b0 <lcd_wr_command>
}
 274:	08 95       	ret

00000276 <lcd_string>:


/*****Function to Print String on LCD*****/
void lcd_string(char *str)
{
 276:	cf 93       	push	r28
 278:	df 93       	push	r29
 27a:	ec 01       	movw	r28, r24
	while(*str != '\0')
 27c:	88 81       	ld	r24, Y
 27e:	88 23       	and	r24, r24
 280:	31 f0       	breq	.+12     	; 0x28e <lcd_string+0x18>
	lcd_wr_command(0x80);
}


/*****Function to Print String on LCD*****/
void lcd_string(char *str)
 282:	21 96       	adiw	r28, 0x01	; 1
{
	while(*str != '\0')
	{
		lcd_wr_char(*str);
 284:	0e 94 12 01 	call	0x224	; 0x224 <lcd_wr_char>


/*****Function to Print String on LCD*****/
void lcd_string(char *str)
{
	while(*str != '\0')
 288:	89 91       	ld	r24, Y+
 28a:	88 23       	and	r24, r24
 28c:	d9 f7       	brne	.-10     	; 0x284 <lcd_string+0xe>
	{
		lcd_wr_char(*str);
		str++;
	}
}
 28e:	df 91       	pop	r29
 290:	cf 91       	pop	r28
 292:	08 95       	ret

00000294 <lcd_cursor>:

/*** Position the LCD cursor at "row", "column". ***/

void lcd_cursor (char row, char column)
{
	switch (row) {
 294:	82 30       	cpi	r24, 0x02	; 2
 296:	79 f0       	breq	.+30     	; 0x2b6 <lcd_cursor+0x22>
 298:	83 30       	cpi	r24, 0x03	; 3
 29a:	18 f4       	brcc	.+6      	; 0x2a2 <lcd_cursor+0xe>
 29c:	81 30       	cpi	r24, 0x01	; 1
 29e:	c9 f4       	brne	.+50     	; 0x2d2 <lcd_cursor+0x3e>
 2a0:	05 c0       	rjmp	.+10     	; 0x2ac <lcd_cursor+0x18>
 2a2:	83 30       	cpi	r24, 0x03	; 3
 2a4:	69 f0       	breq	.+26     	; 0x2c0 <lcd_cursor+0x2c>
 2a6:	84 30       	cpi	r24, 0x04	; 4
 2a8:	a1 f4       	brne	.+40     	; 0x2d2 <lcd_cursor+0x3e>
 2aa:	0f c0       	rjmp	.+30     	; 0x2ca <lcd_cursor+0x36>
		case 1: lcd_wr_command (0x80 + column - 1); break;
 2ac:	86 2f       	mov	r24, r22
 2ae:	81 58       	subi	r24, 0x81	; 129
 2b0:	0e 94 d8 00 	call	0x1b0	; 0x1b0 <lcd_wr_command>
 2b4:	08 95       	ret
		case 2: lcd_wr_command (0xc0 + column - 1); break;
 2b6:	86 2f       	mov	r24, r22
 2b8:	81 54       	subi	r24, 0x41	; 65
 2ba:	0e 94 d8 00 	call	0x1b0	; 0x1b0 <lcd_wr_command>
 2be:	08 95       	ret
		case 3: lcd_wr_command (0x94 + column - 1); break;
 2c0:	86 2f       	mov	r24, r22
 2c2:	8d 56       	subi	r24, 0x6D	; 109
 2c4:	0e 94 d8 00 	call	0x1b0	; 0x1b0 <lcd_wr_command>
 2c8:	08 95       	ret
		case 4: lcd_wr_command (0xd4 + column - 1); break;
 2ca:	86 2f       	mov	r24, r22
 2cc:	8d 52       	subi	r24, 0x2D	; 45
 2ce:	0e 94 d8 00 	call	0x1b0	; 0x1b0 <lcd_wr_command>
 2d2:	08 95       	ret

000002d4 <lcd_print>:
	}
}

/***** Function To Print Any input value upto the desired digit on LCD *****/
void lcd_print (char row, char coloumn, unsigned int value, int digits)
{
 2d4:	0f 93       	push	r16
 2d6:	1f 93       	push	r17
 2d8:	cf 93       	push	r28
 2da:	df 93       	push	r29
 2dc:	8a 01       	movw	r16, r20
 2de:	e9 01       	movw	r28, r18
	unsigned char flag=0;
	if(row==0||coloumn==0)
 2e0:	88 23       	and	r24, r24
 2e2:	11 f0       	breq	.+4      	; 0x2e8 <lcd_print+0x14>
 2e4:	66 23       	and	r22, r22
 2e6:	19 f4       	brne	.+6      	; 0x2ee <lcd_print+0x1a>
	{
		lcd_home();
 2e8:	0e 94 37 01 	call	0x26e	; 0x26e <lcd_home>
 2ec:	02 c0       	rjmp	.+4      	; 0x2f2 <lcd_print+0x1e>
	}
	else
	{
		lcd_cursor(row,coloumn);
 2ee:	0e 94 4a 01 	call	0x294	; 0x294 <lcd_cursor>
	}
	if(digits==5 || flag==1)
 2f2:	c5 30       	cpi	r28, 0x05	; 5
 2f4:	d1 05       	cpc	r29, r1
 2f6:	71 f4       	brne	.+28     	; 0x314 <lcd_print+0x40>
	{
		million=value/10000+48;
 2f8:	c8 01       	movw	r24, r16
 2fa:	60 e1       	ldi	r22, 0x10	; 16
 2fc:	77 e2       	ldi	r23, 0x27	; 39
 2fe:	0e 94 7b 03 	call	0x6f6	; 0x6f6 <__udivmodhi4>
 302:	cb 01       	movw	r24, r22
 304:	c0 96       	adiw	r24, 0x30	; 48
 306:	90 93 3f 02 	sts	0x023F, r25
 30a:	80 93 3e 02 	sts	0x023E, r24
		lcd_wr_char(million);
 30e:	0e 94 12 01 	call	0x224	; 0x224 <lcd_wr_char>
 312:	03 c0       	rjmp	.+6      	; 0x31a <lcd_print+0x46>
		flag=1;
	}
	if(digits==4 || flag==1)
 314:	c4 30       	cpi	r28, 0x04	; 4
 316:	d1 05       	cpc	r29, r1
 318:	b9 f4       	brne	.+46     	; 0x348 <lcd_print+0x74>
	{
		temp = value/1000;
 31a:	c8 01       	movw	r24, r16
 31c:	68 ee       	ldi	r22, 0xE8	; 232
 31e:	73 e0       	ldi	r23, 0x03	; 3
 320:	0e 94 7b 03 	call	0x6f6	; 0x6f6 <__udivmodhi4>
 324:	cb 01       	movw	r24, r22
 326:	70 93 41 02 	sts	0x0241, r23
 32a:	60 93 40 02 	sts	0x0240, r22
		thousand = temp%10 + 48;
 32e:	6a e0       	ldi	r22, 0x0A	; 10
 330:	70 e0       	ldi	r23, 0x00	; 0
 332:	0e 94 7b 03 	call	0x6f6	; 0x6f6 <__udivmodhi4>
 336:	c0 96       	adiw	r24, 0x30	; 48
 338:	90 93 4f 02 	sts	0x024F, r25
 33c:	80 93 4e 02 	sts	0x024E, r24
		lcd_wr_char(thousand);
 340:	0e 94 12 01 	call	0x224	; 0x224 <lcd_wr_char>
		flag=1;
 344:	81 e0       	ldi	r24, 0x01	; 1
 346:	01 c0       	rjmp	.+2      	; 0x34a <lcd_print+0x76>
}

/***** Function To Print Any input value upto the desired digit on LCD *****/
void lcd_print (char row, char coloumn, unsigned int value, int digits)
{
	unsigned char flag=0;
 348:	80 e0       	ldi	r24, 0x00	; 0
		temp = value/1000;
		thousand = temp%10 + 48;
		lcd_wr_char(thousand);
		flag=1;
	}
	if(digits==3 || flag==1)
 34a:	c3 30       	cpi	r28, 0x03	; 3
 34c:	d1 05       	cpc	r29, r1
 34e:	11 f0       	breq	.+4      	; 0x354 <lcd_print+0x80>
 350:	81 30       	cpi	r24, 0x01	; 1
 352:	b1 f4       	brne	.+44     	; 0x380 <lcd_print+0xac>
	{
		temp = value/100;
 354:	c8 01       	movw	r24, r16
 356:	64 e6       	ldi	r22, 0x64	; 100
 358:	70 e0       	ldi	r23, 0x00	; 0
 35a:	0e 94 7b 03 	call	0x6f6	; 0x6f6 <__udivmodhi4>
 35e:	cb 01       	movw	r24, r22
 360:	70 93 41 02 	sts	0x0241, r23
 364:	60 93 40 02 	sts	0x0240, r22
		hundred = temp%10 + 48;
 368:	6a e0       	ldi	r22, 0x0A	; 10
 36a:	70 e0       	ldi	r23, 0x00	; 0
 36c:	0e 94 7b 03 	call	0x6f6	; 0x6f6 <__udivmodhi4>
 370:	c0 96       	adiw	r24, 0x30	; 48
 372:	90 93 4b 02 	sts	0x024B, r25
 376:	80 93 4a 02 	sts	0x024A, r24
		lcd_wr_char(hundred);
 37a:	0e 94 12 01 	call	0x224	; 0x224 <lcd_wr_char>
		flag=1;
 37e:	81 e0       	ldi	r24, 0x01	; 1
	}
	if(digits==2 || flag==1)
 380:	c2 30       	cpi	r28, 0x02	; 2
 382:	d1 05       	cpc	r29, r1
 384:	11 f0       	breq	.+4      	; 0x38a <lcd_print+0xb6>
 386:	81 30       	cpi	r24, 0x01	; 1
 388:	b1 f4       	brne	.+44     	; 0x3b6 <lcd_print+0xe2>
	{
		temp = value/10;
 38a:	2a e0       	ldi	r18, 0x0A	; 10
 38c:	30 e0       	ldi	r19, 0x00	; 0
 38e:	c8 01       	movw	r24, r16
 390:	b9 01       	movw	r22, r18
 392:	0e 94 7b 03 	call	0x6f6	; 0x6f6 <__udivmodhi4>
 396:	cb 01       	movw	r24, r22
 398:	70 93 41 02 	sts	0x0241, r23
 39c:	60 93 40 02 	sts	0x0240, r22
		tens = temp%10 + 48;
 3a0:	b9 01       	movw	r22, r18
 3a2:	0e 94 7b 03 	call	0x6f6	; 0x6f6 <__udivmodhi4>
 3a6:	c0 96       	adiw	r24, 0x30	; 48
 3a8:	90 93 49 02 	sts	0x0249, r25
 3ac:	80 93 48 02 	sts	0x0248, r24
		lcd_wr_char(tens);
 3b0:	0e 94 12 01 	call	0x224	; 0x224 <lcd_wr_char>
		flag=1;
 3b4:	81 e0       	ldi	r24, 0x01	; 1
	}
	if(digits==1 || flag==1)
 3b6:	c1 30       	cpi	r28, 0x01	; 1
 3b8:	d1 05       	cpc	r29, r1
 3ba:	11 f0       	breq	.+4      	; 0x3c0 <lcd_print+0xec>
 3bc:	81 30       	cpi	r24, 0x01	; 1
 3be:	61 f4       	brne	.+24     	; 0x3d8 <lcd_print+0x104>
	{
		unit = value%10 + 48;
 3c0:	c8 01       	movw	r24, r16
 3c2:	6a e0       	ldi	r22, 0x0A	; 10
 3c4:	70 e0       	ldi	r23, 0x00	; 0
 3c6:	0e 94 7b 03 	call	0x6f6	; 0x6f6 <__udivmodhi4>
 3ca:	c0 96       	adiw	r24, 0x30	; 48
 3cc:	90 93 4d 02 	sts	0x024D, r25
 3d0:	80 93 4c 02 	sts	0x024C, r24
		lcd_wr_char(unit);
 3d4:	0e 94 12 01 	call	0x224	; 0x224 <lcd_wr_char>
	}
	if(digits>5)
 3d8:	c6 30       	cpi	r28, 0x06	; 6
 3da:	d1 05       	cpc	r29, r1
 3dc:	1c f0       	brlt	.+6      	; 0x3e4 <lcd_print+0x110>
	{
		lcd_wr_char('E');
 3de:	85 e4       	ldi	r24, 0x45	; 69
 3e0:	0e 94 12 01 	call	0x224	; 0x224 <lcd_wr_char>
	}

}
 3e4:	df 91       	pop	r29
 3e6:	cf 91       	pop	r28
 3e8:	1f 91       	pop	r17
 3ea:	0f 91       	pop	r16
 3ec:	08 95       	ret

000003ee <rgb_port_config>:
void rgb_port_config (void)
{
	/*****************************************
	Define DDR and PORT values for the port on which RGB LED is connected
	******************************************/
	DDRA = DDRA | 0xE0; //port 27->blue_led 28->green_led 29->red_led of port A 
 3ee:	81 b1       	in	r24, 0x01	; 1
 3f0:	80 6e       	ori	r24, 0xE0	; 224
 3f2:	81 b9       	out	0x01, r24	; 1
	PORTA = PORTA | 0xE0;
 3f4:	82 b1       	in	r24, 0x02	; 2
 3f6:	80 6e       	ori	r24, 0xE0	; 224
 3f8:	82 b9       	out	0x02, r24	; 2
}
 3fa:	08 95       	ret

000003fc <red_on>:
*/

//utility functions of rgb led on off

void red_on(void){
	PORTA =  0x60;//set red led to ground(low) for common anode led else set ~0x60 for common cathode
 3fc:	80 e6       	ldi	r24, 0x60	; 96
 3fe:	82 b9       	out	0x02, r24	; 2
}
 400:	08 95       	ret

00000402 <green_on>:

void green_on(void){
	PORTA = 0xA0;//set green led to ground(low) for common anode led else set ~0xA0 for common cathode
 402:	80 ea       	ldi	r24, 0xA0	; 160
 404:	82 b9       	out	0x02, r24	; 2
}
 406:	08 95       	ret

00000408 <blue_on>:

void blue_on(void){
	PORTA = 0xC0;//set blue led to ground(low) for common anode led else set ~0xC0 for common cathode
 408:	80 ec       	ldi	r24, 0xC0	; 192
 40a:	82 b9       	out	0x02, r24	; 2
}
 40c:	08 95       	ret

0000040e <all_off>:

void all_off(void){
	PORTA = 0xFF;//set this for all off for common anode led and 0x00 for common cathode 
 40e:	8f ef       	ldi	r24, 0xFF	; 255
 410:	82 b9       	out	0x02, r24	; 2
}
 412:	08 95       	ret

00000414 <lcd_port_config>:

//lcd init 
void lcd_port_config (void)
{
	DDRC = DDRC | 0xF7; //all the LCD pin's direction set as output
 414:	87 b1       	in	r24, 0x07	; 7
 416:	87 6f       	ori	r24, 0xF7	; 247
 418:	87 b9       	out	0x07, r24	; 7
	PORTC = PORTC & 0x80; // all the LCD pins are set to logic 0 except PORTC 7
 41a:	88 b1       	in	r24, 0x08	; 8
 41c:	80 78       	andi	r24, 0x80	; 128
 41e:	88 b9       	out	0x08, r24	; 8
}
 420:	08 95       	ret

00000422 <lcd_reset>:
//a function to reset the lcd screen to blank screen (wait for 1 second and then reset
void lcd_reset(void){
 422:	cf 93       	push	r28
 424:	df 93       	push	r29
 426:	8f ef       	ldi	r24, 0xFF	; 255
 428:	9f e7       	ldi	r25, 0x7F	; 127
 42a:	af e1       	ldi	r26, 0x1F	; 31
 42c:	81 50       	subi	r24, 0x01	; 1
 42e:	90 40       	sbci	r25, 0x00	; 0
 430:	a0 40       	sbci	r26, 0x00	; 0
 432:	e1 f7       	brne	.-8      	; 0x42c <lcd_reset+0xa>
 434:	00 c0       	rjmp	.+0      	; 0x436 <lcd_reset+0x14>
 436:	00 00       	nop
	_delay_ms(700);
	lcd_cursor(1,1);
 438:	81 e0       	ldi	r24, 0x01	; 1
 43a:	61 e0       	ldi	r22, 0x01	; 1
 43c:	0e 94 4a 01 	call	0x294	; 0x294 <lcd_cursor>
	lcd_string("                ");
 440:	c0 e0       	ldi	r28, 0x00	; 0
 442:	d2 e0       	ldi	r29, 0x02	; 2
 444:	ce 01       	movw	r24, r28
 446:	0e 94 3b 01 	call	0x276	; 0x276 <lcd_string>
	lcd_cursor(2,1);
 44a:	82 e0       	ldi	r24, 0x02	; 2
 44c:	61 e0       	ldi	r22, 0x01	; 1
 44e:	0e 94 4a 01 	call	0x294	; 0x294 <lcd_cursor>
	lcd_string("                ");
 452:	ce 01       	movw	r24, r28
 454:	0e 94 3b 01 	call	0x276	; 0x276 <lcd_string>
}
 458:	df 91       	pop	r29
 45a:	cf 91       	pop	r28
 45c:	08 95       	ret

0000045e <color_sensor_pin_config>:
void color_sensor_pin_config(void)
{
	/*****************************************
	Define DDR and PORT values for the port on which Color sensor is connected
	******************************************/
	DDRB = 0xF0;      //using pins 13->s3 12->s2 11->s1 10->s0
 45e:	80 ef       	ldi	r24, 0xF0	; 240
 460:	84 b9       	out	0x04, r24	; 4
	PORTB = 0x00;
 462:	15 b8       	out	0x05, r1	; 5
	DDRD = DDRD & 0xFE;//using pin 21-> output
 464:	50 98       	cbi	0x0a, 0	; 10
	PORTD = PORTD & 0xFE;
 466:	58 98       	cbi	0x0b, 0	; 11
}
 468:	08 95       	ret

0000046a <color_sensor_pin_interrupt_init>:


void color_sensor_pin_interrupt_init(void) //Interrupt 0 enable
{
	cli(); //Clears the global interrupt
 46a:	f8 94       	cli
	EICRA = EICRA | 0x02; // INT0 is set to trigger with falling edge
 46c:	e9 e6       	ldi	r30, 0x69	; 105
 46e:	f0 e0       	ldi	r31, 0x00	; 0
 470:	80 81       	ld	r24, Z
 472:	82 60       	ori	r24, 0x02	; 2
 474:	80 83       	st	Z, r24
	EIMSK = EIMSK | 0x01; // Enable Interrupt INT0 for color sensor
 476:	e8 9a       	sbi	0x1d, 0	; 29
	sei(); // Enables the global interrupt
 478:	78 94       	sei
}
 47a:	08 95       	ret

0000047c <__vector_1>:

//ISR for color sensor
ISR(INT0_vect) // Pass the timer number in place of n in INTn_vect
{
 47c:	1f 92       	push	r1
 47e:	0f 92       	push	r0
 480:	0f b6       	in	r0, 0x3f	; 63
 482:	0f 92       	push	r0
 484:	11 24       	eor	r1, r1
 486:	8f 93       	push	r24
 488:	9f 93       	push	r25
	//increment on receiving pulse from the color sensor
	++PULSE;
 48a:	80 91 3a 02 	lds	r24, 0x023A
 48e:	90 91 3b 02 	lds	r25, 0x023B
 492:	01 96       	adiw	r24, 0x01	; 1
 494:	90 93 3b 02 	sts	0x023B, r25
 498:	80 93 3a 02 	sts	0x023A, r24
}
 49c:	9f 91       	pop	r25
 49e:	8f 91       	pop	r24
 4a0:	0f 90       	pop	r0
 4a2:	0f be       	out	0x3f, r0	; 63
 4a4:	0f 90       	pop	r0
 4a6:	1f 90       	pop	r1
 4a8:	18 95       	reti

000004aa <init_devices>:

void init_devices(void)
{
	cli(); //Clears the global interrupt
 4aa:	f8 94       	cli
	//Initialize all the ports here
	color_sensor_pin_interrupt_init();
 4ac:	0e 94 35 02 	call	0x46a	; 0x46a <color_sensor_pin_interrupt_init>
	color_sensor_pin_config(); //initialize color sensor pin configuration
 4b0:	0e 94 2f 02 	call	0x45e	; 0x45e <color_sensor_pin_config>
	rgb_port_config();//rgb port config
 4b4:	0e 94 f7 01 	call	0x3ee	; 0x3ee <rgb_port_config>
	lcd_port_config();//lcd port config
 4b8:	0e 94 0a 02 	call	0x414	; 0x414 <lcd_port_config>
	sei();   // Enables the global interrupt
 4bc:	78 94       	sei
}
 4be:	08 95       	ret

000004c0 <filter_red>:
void filter_red(void)    //Used to select red filter
{
	//Filter Select - red filter
	 //set S2 low
	 //set S3 low
	 PORTB = 0x10;
 4c0:	80 e1       	ldi	r24, 0x10	; 16
 4c2:	85 b9       	out	0x05, r24	; 5
	 
}
 4c4:	08 95       	ret

000004c6 <filter_green>:
void filter_green(void)	//Used to select green filter
{
	//Filter Select - green filter
	 //set S2 High
	//set S3 High
	PORTB = 0xD0;
 4c6:	80 ed       	ldi	r24, 0xD0	; 208
 4c8:	85 b9       	out	0x05, r24	; 5
	
}
 4ca:	08 95       	ret

000004cc <filter_blue>:
void filter_blue(void)	//Used to select blue filter
{
	//Filter Select - blue filter
	//set S2 low
	//set S3 High
	PORTB =0x90;
 4cc:	80 e9       	ldi	r24, 0x90	; 144
 4ce:	85 b9       	out	0x05, r24	; 5
	
}
 4d0:	08 95       	ret

000004d2 <filter_clear>:
void filter_clear(void)	//select no filter
{
	//Filter Select - no filter
	//set S2 High
	//set S3 Low
	PORTB = PORTB | 0x80;
 4d2:	2f 9a       	sbi	0x05, 7	; 5
}
 4d4:	08 95       	ret

000004d6 <color_sensor_scaling>:
{
	//Output Scaling 20% from datasheet
	
	//set S0 high
	//set S1 low
	PORTB = 0x10;
 4d6:	80 e1       	ldi	r24, 0x10	; 16
 4d8:	85 b9       	out	0x05, r24	; 5
}
 4da:	08 95       	ret

000004dc <red_read>:

void red_read(void) // function to select red filter and display the count generated by the sensor on LCD. The count will be more if the color is red. The count will be very less if its blue or green.
{
	//Red

	filter_red(); //select red filter
 4dc:	0e 94 60 02 	call	0x4c0	; 0x4c0 <filter_red>
	PULSE=0; //reset the count to 0
 4e0:	10 92 3b 02 	sts	0x023B, r1
 4e4:	10 92 3a 02 	sts	0x023A, r1
 4e8:	8f ef       	ldi	r24, 0xFF	; 255
 4ea:	9f ef       	ldi	r25, 0xFF	; 255
 4ec:	a1 e1       	ldi	r26, 0x11	; 17
 4ee:	81 50       	subi	r24, 0x01	; 1
 4f0:	90 40       	sbci	r25, 0x00	; 0
 4f2:	a0 40       	sbci	r26, 0x00	; 0
 4f4:	e1 f7       	brne	.-8      	; 0x4ee <red_read+0x12>
 4f6:	00 c0       	rjmp	.+0      	; 0x4f8 <red_read+0x1c>
 4f8:	00 00       	nop
	_delay_ms(400); //capture the pulses for 400 ms or 0.4 second to soften red pulse count
}
 4fa:	08 95       	ret

000004fc <green_read>:

void green_read(void) // function to select green filter and display the count generated by the sensor on LCD. The count will be more if the color is green. The count will be very less if its blue or red.
{
	//Green
	
	filter_green(); //select green filter
 4fc:	0e 94 63 02 	call	0x4c6	; 0x4c6 <filter_green>
	PULSE=0; //reset the count to 0
 500:	10 92 3b 02 	sts	0x023B, r1
 504:	10 92 3a 02 	sts	0x023A, r1
 508:	8f ef       	ldi	r24, 0xFF	; 255
 50a:	9f e3       	ldi	r25, 0x3F	; 63
 50c:	a4 e1       	ldi	r26, 0x14	; 20
 50e:	81 50       	subi	r24, 0x01	; 1
 510:	90 40       	sbci	r25, 0x00	; 0
 512:	a0 40       	sbci	r26, 0x00	; 0
 514:	e1 f7       	brne	.-8      	; 0x50e <green_read+0x12>
 516:	00 c0       	rjmp	.+0      	; 0x518 <green_read+0x1c>
 518:	00 00       	nop
	_delay_ms(450); //capture the pulses for 100 ms or 0.1 second
}
 51a:	08 95       	ret

0000051c <blue_read>:

void blue_read(void) // function to select blue filter and display the count generated by the sensor on LCD. The count will be more if the color is blue. The count will be very less if its red or green.
{
	//Blue
	
	filter_blue(); //select blue filter
 51c:	0e 94 66 02 	call	0x4cc	; 0x4cc <filter_blue>
	PULSE=0; //reset the count to 0
 520:	10 92 3b 02 	sts	0x023B, r1
 524:	10 92 3a 02 	sts	0x023A, r1
 528:	8f ef       	ldi	r24, 0xFF	; 255
 52a:	9f e3       	ldi	r25, 0x3F	; 63
 52c:	a4 e1       	ldi	r26, 0x14	; 20
 52e:	81 50       	subi	r24, 0x01	; 1
 530:	90 40       	sbci	r25, 0x00	; 0
 532:	a0 40       	sbci	r26, 0x00	; 0
 534:	e1 f7       	brne	.-8      	; 0x52e <blue_read+0x12>
 536:	00 c0       	rjmp	.+0      	; 0x538 <blue_read+0x1c>
 538:	00 00       	nop
	_delay_ms(450); //capture the pulses for 100 ms or 0.1 second
}	
 53a:	08 95       	ret

0000053c <main>:

int main(void)
{
	int choice;
    init_devices();
 53c:	0e 94 55 02 	call	0x4aa	; 0x4aa <init_devices>
	color_sensor_scaling();
 540:	0e 94 6b 02 	call	0x4d6	; 0x4d6 <color_sensor_scaling>
	lcd_set_4bit();
 544:	0e 94 95 00 	call	0x12a	; 0x12a <lcd_set_4bit>
	lcd_init();
 548:	0e 94 fd 00 	call	0x1fa	; 0x1fa <lcd_init>
	  lcd_reset();
	 if ((red < rthreshold) && (green < gthreshold) && (blue < bthreshold))
	  {
		  all_off();
		  lcd_cursor(1,1);
		  lcd_string("No Nut");
 54c:	0f 2e       	mov	r0, r31
 54e:	f1 e1       	ldi	r31, 0x11	; 17
 550:	cf 2e       	mov	r12, r31
 552:	f2 e0       	ldi	r31, 0x02	; 2
 554:	df 2e       	mov	r13, r31
 556:	f0 2d       	mov	r31, r0
						lcd_string("GREEN Nut");
						lcd_reset();
						break;
				  case 3:blue_on();
						lcd_cursor(1,1);
						lcd_string("blue Nut");
 558:	c8 e1       	ldi	r28, 0x18	; 24
 55a:	d2 e0       	ldi	r29, 0x02	; 2
						lcd_string("RED Nut");
						lcd_reset();
						break;
				  case 2:green_on();
						lcd_cursor(1,1);
						lcd_string("GREEN Nut");
 55c:	09 e2       	ldi	r16, 0x29	; 41
 55e:	12 e0       	ldi	r17, 0x02	; 2
			  choice = (red > green)?((red > blue)?1:3):((green > blue)?2:3);
			  switch(choice)
			  {
				  case 1:red_on();
						lcd_cursor(1,1);
						lcd_string("RED Nut");
 560:	0f 2e       	mov	r0, r31
 562:	f1 e2       	ldi	r31, 0x21	; 33
 564:	ef 2e       	mov	r14, r31
 566:	f2 e0       	ldi	r31, 0x02	; 2
 568:	ff 2e       	mov	r15, r31
 56a:	f0 2d       	mov	r31, r0
	lcd_init();
	
	
	while(1)
    {
      red_read();
 56c:	0e 94 6e 02 	call	0x4dc	; 0x4dc <red_read>
	  red = PULSE;//store the count in variable called red
 570:	80 91 3a 02 	lds	r24, 0x023A
 574:	90 91 3b 02 	lds	r25, 0x023B
 578:	90 93 45 02 	sts	0x0245, r25
 57c:	80 93 44 02 	sts	0x0244, r24
	  lcd_cursor(1,1);
 580:	81 e0       	ldi	r24, 0x01	; 1
 582:	61 e0       	ldi	r22, 0x01	; 1
 584:	0e 94 4a 01 	call	0x294	; 0x294 <lcd_cursor>
	  lcd_print(1,1,1,1);
 588:	81 e0       	ldi	r24, 0x01	; 1
 58a:	61 e0       	ldi	r22, 0x01	; 1
 58c:	41 e0       	ldi	r20, 0x01	; 1
 58e:	50 e0       	ldi	r21, 0x00	; 0
 590:	21 e0       	ldi	r18, 0x01	; 1
 592:	30 e0       	ldi	r19, 0x00	; 0
 594:	0e 94 6a 01 	call	0x2d4	; 0x2d4 <lcd_print>
	  lcd_print(2,1,red,5);
 598:	40 91 44 02 	lds	r20, 0x0244
 59c:	50 91 45 02 	lds	r21, 0x0245
 5a0:	82 e0       	ldi	r24, 0x02	; 2
 5a2:	61 e0       	ldi	r22, 0x01	; 1
 5a4:	25 e0       	ldi	r18, 0x05	; 5
 5a6:	30 e0       	ldi	r19, 0x00	; 0
 5a8:	0e 94 6a 01 	call	0x2d4	; 0x2d4 <lcd_print>
	  lcd_reset();
 5ac:	0e 94 11 02 	call	0x422	; 0x422 <lcd_reset>
	  green_read();
 5b0:	0e 94 7e 02 	call	0x4fc	; 0x4fc <green_read>
	  green = PULSE;//store the count in variable called green
 5b4:	80 91 3a 02 	lds	r24, 0x023A
 5b8:	90 91 3b 02 	lds	r25, 0x023B
 5bc:	90 93 43 02 	sts	0x0243, r25
 5c0:	80 93 42 02 	sts	0x0242, r24
	  lcd_print(1,1,2,1);
 5c4:	81 e0       	ldi	r24, 0x01	; 1
 5c6:	61 e0       	ldi	r22, 0x01	; 1
 5c8:	42 e0       	ldi	r20, 0x02	; 2
 5ca:	50 e0       	ldi	r21, 0x00	; 0
 5cc:	21 e0       	ldi	r18, 0x01	; 1
 5ce:	30 e0       	ldi	r19, 0x00	; 0
 5d0:	0e 94 6a 01 	call	0x2d4	; 0x2d4 <lcd_print>
	  lcd_print(2,1,green,5);
 5d4:	40 91 42 02 	lds	r20, 0x0242
 5d8:	50 91 43 02 	lds	r21, 0x0243
 5dc:	82 e0       	ldi	r24, 0x02	; 2
 5de:	61 e0       	ldi	r22, 0x01	; 1
 5e0:	25 e0       	ldi	r18, 0x05	; 5
 5e2:	30 e0       	ldi	r19, 0x00	; 0
 5e4:	0e 94 6a 01 	call	0x2d4	; 0x2d4 <lcd_print>
	  lcd_reset();
 5e8:	0e 94 11 02 	call	0x422	; 0x422 <lcd_reset>
	  blue_read();
 5ec:	0e 94 8e 02 	call	0x51c	; 0x51c <blue_read>
	  blue = PULSE;//store the count in variable called blue
 5f0:	80 91 3a 02 	lds	r24, 0x023A
 5f4:	90 91 3b 02 	lds	r25, 0x023B
 5f8:	90 93 3d 02 	sts	0x023D, r25
 5fc:	80 93 3c 02 	sts	0x023C, r24
	  lcd_print(1,1,3,1);
 600:	81 e0       	ldi	r24, 0x01	; 1
 602:	61 e0       	ldi	r22, 0x01	; 1
 604:	43 e0       	ldi	r20, 0x03	; 3
 606:	50 e0       	ldi	r21, 0x00	; 0
 608:	21 e0       	ldi	r18, 0x01	; 1
 60a:	30 e0       	ldi	r19, 0x00	; 0
 60c:	0e 94 6a 01 	call	0x2d4	; 0x2d4 <lcd_print>
	  lcd_print(2,1,blue,5);
 610:	40 91 3c 02 	lds	r20, 0x023C
 614:	50 91 3d 02 	lds	r21, 0x023D
 618:	82 e0       	ldi	r24, 0x02	; 2
 61a:	61 e0       	ldi	r22, 0x01	; 1
 61c:	25 e0       	ldi	r18, 0x05	; 5
 61e:	30 e0       	ldi	r19, 0x00	; 0
 620:	0e 94 6a 01 	call	0x2d4	; 0x2d4 <lcd_print>
	  lcd_reset();
 624:	0e 94 11 02 	call	0x422	; 0x422 <lcd_reset>
	 if ((red < rthreshold) && (green < gthreshold) && (blue < bthreshold))
 628:	40 91 44 02 	lds	r20, 0x0244
 62c:	50 91 45 02 	lds	r21, 0x0245
 630:	80 91 37 02 	lds	r24, 0x0237
 634:	90 91 38 02 	lds	r25, 0x0238
 638:	48 17       	cp	r20, r24
 63a:	59 07       	cpc	r21, r25
 63c:	10 f5       	brcc	.+68     	; 0x682 <main+0x146>
 63e:	80 91 42 02 	lds	r24, 0x0242
 642:	90 91 43 02 	lds	r25, 0x0243
 646:	20 91 35 02 	lds	r18, 0x0235
 64a:	30 91 36 02 	lds	r19, 0x0236
 64e:	82 17       	cp	r24, r18
 650:	93 07       	cpc	r25, r19
 652:	b8 f4       	brcc	.+46     	; 0x682 <main+0x146>
 654:	80 91 3c 02 	lds	r24, 0x023C
 658:	90 91 3d 02 	lds	r25, 0x023D
 65c:	20 91 33 02 	lds	r18, 0x0233
 660:	30 91 34 02 	lds	r19, 0x0234
 664:	82 17       	cp	r24, r18
 666:	93 07       	cpc	r25, r19
 668:	60 f4       	brcc	.+24     	; 0x682 <main+0x146>
	  {
		  all_off();
 66a:	0e 94 07 02 	call	0x40e	; 0x40e <all_off>
		  lcd_cursor(1,1);
 66e:	81 e0       	ldi	r24, 0x01	; 1
 670:	61 e0       	ldi	r22, 0x01	; 1
 672:	0e 94 4a 01 	call	0x294	; 0x294 <lcd_cursor>
		  lcd_string("No Nut");
 676:	c6 01       	movw	r24, r12
 678:	0e 94 3b 01 	call	0x276	; 0x276 <lcd_string>
		  lcd_reset();
 67c:	0e 94 11 02 	call	0x422	; 0x422 <lcd_reset>
 680:	75 cf       	rjmp	.-278    	; 0x56c <main+0x30>
	  }
	  else
	  {
			  choice = (red > green)?((red > blue)?1:3):((green > blue)?2:3);
 682:	80 91 42 02 	lds	r24, 0x0242
 686:	90 91 43 02 	lds	r25, 0x0243
 68a:	84 17       	cp	r24, r20
 68c:	95 07       	cpc	r25, r21
 68e:	40 f4       	brcc	.+16     	; 0x6a0 <main+0x164>
 690:	80 91 3c 02 	lds	r24, 0x023C
 694:	90 91 3d 02 	lds	r25, 0x023D
 698:	84 17       	cp	r24, r20
 69a:	95 07       	cpc	r25, r21
 69c:	a0 f0       	brcs	.+40     	; 0x6c6 <main+0x18a>
 69e:	07 c0       	rjmp	.+14     	; 0x6ae <main+0x172>
 6a0:	20 91 3c 02 	lds	r18, 0x023C
 6a4:	30 91 3d 02 	lds	r19, 0x023D
 6a8:	28 17       	cp	r18, r24
 6aa:	39 07       	cpc	r19, r25
 6ac:	c0 f0       	brcs	.+48     	; 0x6de <main+0x1a2>
				  case 2:green_on();
						lcd_cursor(1,1);
						lcd_string("GREEN Nut");
						lcd_reset();
						break;
				  case 3:blue_on();
 6ae:	0e 94 04 02 	call	0x408	; 0x408 <blue_on>
						lcd_cursor(1,1);
 6b2:	81 e0       	ldi	r24, 0x01	; 1
 6b4:	61 e0       	ldi	r22, 0x01	; 1
 6b6:	0e 94 4a 01 	call	0x294	; 0x294 <lcd_cursor>
						lcd_string("blue Nut");
 6ba:	ce 01       	movw	r24, r28
 6bc:	0e 94 3b 01 	call	0x276	; 0x276 <lcd_string>
						lcd_reset();
 6c0:	0e 94 11 02 	call	0x422	; 0x422 <lcd_reset>
						break;
 6c4:	53 cf       	rjmp	.-346    	; 0x56c <main+0x30>
	  else
	  {
			  choice = (red > green)?((red > blue)?1:3):((green > blue)?2:3);
			  switch(choice)
			  {
				  case 1:red_on();
 6c6:	0e 94 fe 01 	call	0x3fc	; 0x3fc <red_on>
						lcd_cursor(1,1);
 6ca:	81 e0       	ldi	r24, 0x01	; 1
 6cc:	61 e0       	ldi	r22, 0x01	; 1
 6ce:	0e 94 4a 01 	call	0x294	; 0x294 <lcd_cursor>
						lcd_string("RED Nut");
 6d2:	c7 01       	movw	r24, r14
 6d4:	0e 94 3b 01 	call	0x276	; 0x276 <lcd_string>
						lcd_reset();
 6d8:	0e 94 11 02 	call	0x422	; 0x422 <lcd_reset>
						break;
 6dc:	47 cf       	rjmp	.-370    	; 0x56c <main+0x30>
				  case 2:green_on();
 6de:	0e 94 01 02 	call	0x402	; 0x402 <green_on>
						lcd_cursor(1,1);
 6e2:	81 e0       	ldi	r24, 0x01	; 1
 6e4:	61 e0       	ldi	r22, 0x01	; 1
 6e6:	0e 94 4a 01 	call	0x294	; 0x294 <lcd_cursor>
						lcd_string("GREEN Nut");
 6ea:	c8 01       	movw	r24, r16
 6ec:	0e 94 3b 01 	call	0x276	; 0x276 <lcd_string>
						lcd_reset();
 6f0:	0e 94 11 02 	call	0x422	; 0x422 <lcd_reset>
						break;
 6f4:	3b cf       	rjmp	.-394    	; 0x56c <main+0x30>

000006f6 <__udivmodhi4>:
 6f6:	aa 1b       	sub	r26, r26
 6f8:	bb 1b       	sub	r27, r27
 6fa:	51 e1       	ldi	r21, 0x11	; 17
 6fc:	07 c0       	rjmp	.+14     	; 0x70c <__udivmodhi4_ep>

000006fe <__udivmodhi4_loop>:
 6fe:	aa 1f       	adc	r26, r26
 700:	bb 1f       	adc	r27, r27
 702:	a6 17       	cp	r26, r22
 704:	b7 07       	cpc	r27, r23
 706:	10 f0       	brcs	.+4      	; 0x70c <__udivmodhi4_ep>
 708:	a6 1b       	sub	r26, r22
 70a:	b7 0b       	sbc	r27, r23

0000070c <__udivmodhi4_ep>:
 70c:	88 1f       	adc	r24, r24
 70e:	99 1f       	adc	r25, r25
 710:	5a 95       	dec	r21
 712:	a9 f7       	brne	.-22     	; 0x6fe <__udivmodhi4_loop>
 714:	80 95       	com	r24
 716:	90 95       	com	r25
 718:	bc 01       	movw	r22, r24
 71a:	cd 01       	movw	r24, r26
 71c:	08 95       	ret

0000071e <_exit>:
 71e:	f8 94       	cli

00000720 <__stop_program>:
 720:	ff cf       	rjmp	.-2      	; 0x720 <__stop_program>
